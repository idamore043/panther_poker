import random
import sys
import io
import numpy as np
from collections import deque
from keras.models import Sequential
from keras.layers import Dense
from keras.optimizers import Adam

sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

class PokerAI:
    def __init__(self, state_size, action_size):
        self.state_size = state_size  # Dimension of the game state
        self.action_size = action_size  # Number of possible actions
        self.memory = deque(maxlen=2000)  # Memory for experience replay
        self.gamma = 0.95  # Discount rate for future rewards
        self.epsilon = 1.0  # Exploration rate
        self.epsilon_min = 0.01  # Minimum exploration rate
        self.epsilon_decay = 0.995  # Decay rate for exploration probability
        self.learning_rate = 0.001  # Learning rate
        self.model = self._build_model()  # Build the neural network model
        
    def _build_model(self):
        # Neural Net for Deep-Q learning Model
        model = Sequential()
        model.add(Dense(24, input_dim=self.state_size, activation='relu'))
        model.add(Dense(24, activation='relu'))
        model.add(Dense(self.action_size, activation='linear'))
        model.compile(loss='mse', optimizer=Adam(lr=self.learning_rate))
        return model

    def remember(self, state, action, reward, next_state, done):
        # Store experiences in memory
        self.memory.append((state, action, reward, next_state, done))

    def act(self, state):
        # Return action based on model prediction or exploration
        if np.random.rand() <= self.epsilon:
            return random.randrange(self.action_size)
        act_values = self.model.predict(state)
        return np.argmax(act_values[0])  # Returns action with the highest reward prediction

    def replay(self, batch_size):
        # Train the model with experiences sampled from memory
        minibatch = random.sample(self.memory, batch_size)
        for state, action, reward, next_state, done in minibatch:
            target = reward
            if not done:
                target = reward + self.gamma * np.amax(self.model.predict(next_state)[0])
            target_f = self.model.predict(state)
            target_f[0][action] = target
            self.model.fit(state, target_f, epochs=1, verbose=0)
        if self.epsilon > self.epsilon_min:
            self.epsilon *= self.epsilon_decay

    def load(self, name):
        # Load a model
        self.model.load_weights(name)

    def save(self, name):
        # Save the model
        self.model.save_weights(name)

class PokerLogic:
    def evaluate_hand(self, hole_cards):  # Evaluate the strength of a poker hand given the hole cards and community cards
        # Ensure hole_cards is a list
        if isinstance(hole_cards, dict):
            hole_cards = [hole_cards]

        # Combine hole cards with community cards to form the full hand
        full_hand = hole_cards # + community_cards

        # Separate cards by suit and value
        cards_by_suit = {}
        cards_by_value = {}

        # Evaluate the strength of the hand
        for card in full_hand:
            suit = card['suit']
            value = card['value']

            if suit not in cards_by_suit:
                cards_by_suit[suit] = []
            cards_by_suit[suit].append(value)

            if value not in cards_by_value:
                cards_by_value[value] = []
            cards_by_value[value].append(suit)

        # Check for Royal Flush
        for suit, values in cards_by_suit.items():
            if '10' in values and 'J' in values and 'Q' in values and 'K' in values and 'A' in values:
                return 'Royal Flush', 10

        # Check for Straight Flush
        for suit, values in cards_by_suit.items():
            straight_values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
            for i in range(len(straight_values) - 4):
                if all(value in values for value in straight_values[i:i + 5]):
                    return 'Straight Flush', 9

        # Check for Four of a Kind
        for value, suits in cards_by_value.items():
            if len(suits) >= 4:
                return 'Four of a Kind', 8

        # Check for Full House
        has_three = False
        has_pair = False
        for value, suits in cards_by_value.items():
            if len(suits) >= 3:
                has_three = True
            elif len(suits) >= 2:
                has_pair = True
        if has_three and has_pair:
            return 'Full House', 7

        # Check for Flush
        for suit, values in cards_by_suit.items():
            if len(values) >= 5:
                return 'Flush', 6

        # Check for Straight
        for value, suits in cards_by_value.items():
            straight_values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
            for i in range(len(straight_values) - 4):
                if all(suit in cards_by_suit and value in cards_by_suit[suit] for value in straight_values[i:i + 5]):
                    return 'Straight', 5

        # Check for Three of a Kind
        for value, suits in cards_by_value.items():
            if len(suits) >= 3:
                return 'Three of a Kind', 4

        # Check for Two Pair
        num_pairs = 0
        for value, suits in cards_by_value.items():
            if len(suits) >= 2:
                num_pairs += 1
        if num_pairs >= 2:
            return 'Two Pair', 3

        # Check for One Pair
        for value, suits in cards_by_value.items():
            if len(suits) >= 2:
                return 'One Pair', 2

        # If none of the above, it's High Card
        return 'High Card', 1

    def card_ascii(self, card): # Return an ASCII representation of a card
        suit = card['suit']
        value = card['value']
        suits_ascii = {'Hearts': '♥','Diamonds': '♦','Clubs': '♣','Spades': '♠'}

        values_ascii = {'2': '2', '3': '3', '4': '4', '5': '5','6': '6',
                        '7': '7', '8': '8', '9': '9','10': '10',
                        'J': 'J', 'Q': 'Q', 'K': 'K', 'A': 'A'}

        return (
            f"┌─────────┐\n"
            f"│ {values_ascii[value]:<2}      │\n"
            f"│         │\n"
            f"│    {suits_ascii[suit]}    │\n"
            f"│         │\n"
            f"│      {values_ascii[value]:>2} │\n"
            f"└─────────┘"
        )
    
    def simple_card_print(self, cards): # Simple card printing method for debugging and testing
        suits_ascii = {'Hearts': '♥', 'Diamonds': '♦', 'Clubs': '♣', 'Spades': '♠'}
        values_ascii = {'2': '2', '3': '3', '4': '4', '5': '5', '6': '6',
                        '7': '7', '8': '8', '9': '9', '10': '10',
                        'J': 'J', 'Q': 'Q', 'K': 'K', 'A': 'A'}

        card_strings = []
        for card in cards:
            suit = card['suit']
            value = card['value']
            card_str = f"{values_ascii[value]}{suits_ascii[suit]}"
            card_strings.append(card_str)

        print(" ".join(card_strings))

    def estimate_win_rate(self, hand_strength): # Estimate the win rate based on the strength of the hand
        # Rough probabilities of winning based on hand strength
        win_rate = {
            10: 0.90,  # Royal Flush
            9: 0.80,  # Straight Flush
            8: 0.70,  # Four of a Kind
            7: 0.60,  # Full House
            6: 0.50,  # Flush
            5: 0.40,  # Straight
            4: 0.30,  # Three of a Kind
            3: 0.20,  # Two Pair
            2: 0.10,  # One Pair
            1: 0.05  # High Card
        }
        return win_rate.get(hand_strength, 0)
    
    def hand_rank(self, hand): # Return a numerical rank for a given hand (e.g., 'Two Pair' -> 3)
        rank_order = {
            'High Card': 0,
            'One Pair': 1,
            'Two Pair': 2,
            'Three of a Kind': 3,
            'Straight': 4,
            'Flush': 5,
            'Full House': 6,
            'Four of a Kind': 7,
            'Straight Flush': 8,
            'Royal Flush': 9
        }
        return rank_order[hand]

class PokerGame:
    def __init__(self, players): # Initialize a poker game with the given number of players
        self.continue_game = True  # New attribute to keep playing when player fold
        self.player_out = False # New flag to check if player is out of chips

        self.deck = self.create_deck()
        self.shuffle_deck()
        self.players = players
        self.community_cards = []
        # Modified the player to have 2 additional parameters hand strength that will vary from 10 to 1 and a very basic win rate change that will
        # vary from .90 to .05
        self.hands = {player: {'cards': [],'current_bet':0, 'win_rate': 0, 'hand_strength': 0} for player in range(players)}
        self.pot = 0
        self.player_chips = [1000] * players # Initialize player chips with 1000 for each player
        self.small_blind = 5  # Small blind amount
        self.big_blind = 2 * self.small_blind  # Big blind amount
        self.poker_logic = PokerLogic()
        self.current_bet = 0  # Initialize current bet to zero
        self.player_label = "Player 1" # Define Player's Name
        self.ai_label = "Player 2"  # Define AI's Name

    def create_deck(self): # Create a standard deck of 52 playing cards
        suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades']
        values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
        return [{'suit': suit, 'value': value} for suit in suits for value in values]

    def shuffle_deck(self): # Shuffle the deck of cards
        random.shuffle(self.deck)
    
    def update_hs_and_wr(self):
        for player in range(self.players):
            # Evaluate the current hand strength
            hand_strength_info = self.poker_logic.evaluate_hand(self.hands[player]['cards'])
            self.hands[player]['hand_strength'] = hand_strength_info[1]
            # Update win rates based on the new hand strength
            self.hands[player]['win_rate'] = self.poker_logic.estimate_win_rate(hand_strength_info[1])
    
    def deal_hole_cards(self): # Deal two private cards to each player   
        for _ in range(2):
            for player in range(self.players):
                card = self.deck.pop()
                self.hands[player]['cards'].append(card)
                if player == 0: # Only print cards for the player playing the game
                    # print(self.poker_logic.card_ascii(card))
                    if len(self.hands[player]['cards']) == 2:  # Check if it's the second card to print both together
                      self.poker_logic.simple_card_print(self.hands[player]['cards'])
        self.update_hs_and_wr() # Update hand strength and win rate here  
                    
    def deal_community_card(self, count): # Deal a specified number of community cards   
        new_cards = []
        for _ in range(count):
            card = self.deck.pop()
            self.community_cards.append(card)
            new_cards.append(card)
            # Removed ASCII card printing for debugging and testing
            # print(self.poker_logic.card_ascii(card))
        self.poker_logic.simple_card_print(self.community_cards) # Print all community cards together
        
        # Append the new community cards to each player's hand
        for player in range(self.players):
            self.hands[player]['cards'].extend(new_cards)
        self.update_hs_and_wr() # Update hand strength and win rate here
        
    def print_stacks(self): # Print the current chip stacks for each player
        print("\033[1mPlayer Stacks:\033[0m")
        for player, chips in enumerate(self.player_chips):
            print(f"Player {player + 1} has {chips} chips.")

    def print_pot(self): # Print the current total pot
        print("\033[1mCurrent Pot:\033[0m")
        print(f"{self.pot} chips.")

    def distribute_pot(self, winners): # Distribute the pot among the winning players
        share = self.pot // len(winners)
        for winner in winners:
            self.player_chips[winner] += share
        self.pot = 0

    def showdown(self): # Determine the winner(s) of the game and distribute the pot.
        print("\n\033[1mShowdown:\033[0m")
        # Evaluate best hand for each player
        best_hands = {player: self.poker_logic.evaluate_hand(self.hands[player]['cards']) for player in range(self.players)}

        # Determine the winners
        best_hand_strength = max([hand[1] for hand in best_hands.values()])
        winners = [player for player, hand in best_hands.items() if hand[1] == best_hand_strength]

        # Distribute pot to winners
        self.distribute_pot(winners)
        
        # Print results for each player
        for player in range(self.players):
            print(f"Player {player + 1}'s hand:")
            self.poker_logic.simple_card_print(self.hands[player]['cards'])
            # print(self.poker_logic.card_ascii(card))

            print(f"{'Player 1' if player == 0 else 'Player 2'}'s best hand: {best_hands[player][0]} (strength: {best_hands[player][1]})")
            print(f"{'Player 1' if player == 0 else 'Player 2'}'s estimated win rate: {self.hands[player]['win_rate']:.2f}%")

        # Removed ASCII card printing for debugging and testing
        # print("\033[1mCommunity Cards:\033[0m")
        # for card in self.community_cards:
        #      print(self.poker_logic.card_ascii(card))
        #    self.poker_logic.simple_card_print(self.community_cards)
            
        # Print winners and their winning hands
        if len(winners) == 1:
            print(f"\nPlayer {winners[0] + 1} wins with {best_hands[winners[0]][0]}!")
        else:
            tied_players = ' and '.join([f"Player {winner + 1}" for winner in winners])
            print(f"\nIt's a tie between {tied_players} with {best_hands[winners[0]][0]}!")

    def find_winner(self, player_hands):
        best_hands = {player: self.poker_logic.evaluate_hand(player_hands[player]['cards'], self.community_cards) for player in range(self.players)}
        best_hand_value = max(best_hands.values(), key=lambda x: self.hand_rank(x[0]))
        winners = [player for player, hand in best_hands.items() if hand[0] == best_hand_value[0]]
        return winners

    def simulate_blind_round(self): # Simulate the initial blind betting round
        # Ask the player if they want to post the small blind to begin the game
        print("\n\033[1mBlind Betting:\033[0m")
        while True:
            action = input(f"{self.player_label}, do you want to post the small blind (5 chips)? (yes/no): ")
            if action == "yes":
                # Subtract small blind from player 1 chips.
                small_blind_amount = min(self.small_blind, self.player_chips[0])
                self.player_chips[0] -= small_blind_amount
                # Add small blind to pot.
                self.pot += small_blind_amount
                print(f"{self.player_label} posts small blind of {small_blind_amount} chips.")
                break
            elif action == "no":
                print(f"{self.player_label} opts not to post the small blind.")
                # AI automatically wins if player doesn't post small blind.
                print(f"{self.ai_label} wins by default!")
            else:
                print("Invalid input. Please enter 'yes' or 'no'.")
                
        # AI posts big blind.
        big_blind_amount = min(self.big_blind, self.player_chips[1])
        # Subtract big blind from AI chips.
        self.player_chips[1] -= big_blind_amount
        # Add big blind to pot.
        self.pot += big_blind_amount
        print(f"{self.ai_label} posts big blind of {big_blind_amount} chips.")
        self.print_stacks()
        self.print_pot()

    def play_private_round (self): # Method for private card rounds of poker
        print("\n\033[1mDealt Private Cards to Players:\033[0m")
        self.deal_hole_cards()
        self.simulate_betting_round()
        self.print_stacks()
        self.print_pot()

    def play_community_round (self, round_name, community_card_count): # Method for community card rounds of poker
        print(f"\n\033[1m{round_name}:\033[0m")
        self.deal_community_card(community_card_count)
        self.simulate_betting_round()
        self.print_stacks()
        self.print_pot()
    
    def reset_for_new_round (self):
        self.deck = self.create_deck()  # Recreate the deck
        self.shuffle_deck()  # Reshuffle deck
        self.community_cards = []  # Clear community cards
        self.pot = 0  # Reset the pot
        self.hands = {player: {'cards': [], 'current_bet': 0, 'win_rate': 0, 'hand_strength': 0, 'folded': False} for player in range(self.players)}

    def play (self):
        while self.player_chips[0] > 0:  # Loop until Player 1 has no chips
            self.continue_game = True  # Reset the flag for each new game

            self.simulate_blind_round()
            if not self.continue_game:
                continue
            self.play_private_round()
            if not self.continue_game:
                continue
            self.play_community_round("Dealt the Flop", 3)
            if not self.continue_game:
                continue
            self.play_community_round("Dealt the Turn", 1)
            if not self.continue_game:
                continue
            self.play_community_round("Dealt the River", 1)
            if not self.continue_game:
                continue

            self.showdown()  # Run showdown at the end of each game

            # Reset for the next game
            self.reset_for_new_round()
            
            # After exiting the loop, identify which player(s) ran out of chips.
            for i, chips in enumerate(self.player_chips):
                if chips <= 0:
                    print(f"Game over! Player {i + 1} is out of chips.")

    def simulate_betting_round(self):
      current_bet = 0
      total_bets = 0
      player_actions_completed = [False] * self.players
      
      while not all(player_actions_completed):
          for player in range(self.players):
              if self.player_chips[player] > 0 and not self.hands[player].get('folded', False):
                  if self.hands[player].get('current_bet', 0) < current_bet or not player_actions_completed[player]:
                      if player == 0:  # Human player
                          print(f"Current bet to match: {current_bet}")
                          print(f"{self.player_label}'s current bet: {self.hands[player].get('current_bet', 0)}")
                          action = self.get_player_action(player, current_bet)
                      else:  # AI decision-making (simplified here for demonstration)
                          action = self.ai_decision(player, current_bet) # We need to define this method for AI actions
                          player_actions_completed[player] = True

                      if action == "check":
                          if current_bet == 0:
                              print(f"{self.player_label} checks.")
                              player_actions_completed[player] = True
                          else:
                              print("Checking not allowed, current bet is higher.")
                      elif action == "call":
                          call_amount = current_bet - self.hands[player].get('current_bet', 0)
                          self.player_bet(player, call_amount)
                          total_bets += call_amount
                          player_actions_completed[player] = True
                      elif action == "raise":
                          raise_amount = self.get_bet_amount(player, current_bet)
                          if raise_amount > current_bet:
                              self.player_bet(player, raise_amount - self.hands[player].get('current_bet', 0))
                              total_bets += raise_amount
                              current_bet = raise_amount
                              player_actions_completed = [False] * self.players  # Reset actions
                              player_actions_completed[player] = True
                      elif action == "fold":
                        self.player_fold(player)
                        player_actions_completed[player] = True
                        # End the round immediately when a fold occurs
                        return
                  else:
                      player_actions_completed[player] = True  # This player has already matched the bet or folded
              else:
                  player_actions_completed[player] = True  # No action required because player has no chips or has folded

          # Check if the round should end
          if total_bets == current_bet * sum(not self.hands[i].get('folded', False) for i in range(self.players)):
              break  # Exit loop if total bets match expected total for all calls
        
    def get_player_action(self, player, current_bet):
      while True:
          if current_bet == 0:
            print(f"\033[1m{self.player_label}'s Turn:\033[0m")
            print(f"{self.player_label}, would you like to 'call', 'raise', or 'fold'.")
            response = input("Select your action: ")
          else :
            print(f"{self.player_label}, would you like to 'call', 'raise', or 'fold'.")
            response = input("Select your action: ")
          if response in ["call", "raise", "fold", "check"]:
              return response
          print("Invalid input.")
          
    def get_bet_amount(self, player, current_bet):
        while True:
            print(f"{self.player_label}, choose your bet amount:")
            print("1: Call the current bet.")
            print("2: Raise by 25 chips.")
            print("3: Raise by 50 chips.")
            choice = input("Select option '1', '2', or '3': ")
            if choice == '1':
                return current_bet  # Player chooses to call
            elif choice == '2':
                if self.player_chips[player] >= current_bet + 25:
                    return current_bet + 25  # Player chooses to raise by 25
                else:
                    print("Not enough chips to raise by 25.")
            elif choice == '3':
                if self.player_chips[player] >= current_bet + 50:
                    return current_bet + 50  # Player chooses to raise by 50
                else:
                    print("Not enough chips to raise by 50.")
            else:
                print("Invalid input.")

    def player_bet(self, player, bet_amount):
        if bet_amount < 0:
            print("Error: Bet amount cannot be negative.")
            return
        if bet_amount > self.player_chips[player]:
            print("Not enough chips. You cannot bet more than you have.")
            return
        self.player_chips[player] -= bet_amount
        self.hands[player]['current_bet'] += bet_amount
        self.pot += bet_amount
        print(f"{self.player_label} bets {bet_amount} chips.")
        # Ensure current_bet on the game level is updated to reflect the highest current bet
        self.current_bet = max(self.current_bet, self.hands[player]['current_bet'])
    
    def player_checks(self, bet_active):
        if bet_active:
            raise ValueError(f"{self.player_label} cannot check when a bet has been made.")
        else:
            print(f"{self.player_label} checks.")

    def player_fold(self, player):
        # Player folds
        print(f"{self.player_label} folds.")

        # Set the fold status for the player
        self.hands[player]['folded'] = True

        # Find the remaining player who hasn't folded
        other_player = next(player for player in range(self.players) if not self.hands[player].get('folded', False))
        print(f"Player {other_player + 1} wins by default!")
        self.distribute_pot([other_player])

        # End the game
        self.continue_game = False
        self.reset_for_new_round()

    ## delete Turn AI stament just there for understanding of the descition
    def ai_decision(self, player, current_bet):
        # self.poker_logic.simple_card_print(self.hands[player]['cards'])  # For debugging purposes. AI hole cards should not be visible.
        print(f"\033[1m{self.ai_label}'s Turn:\033[0m")
        
        # AI win rate and hand strength should not be visible. 
        hand_strength = self.poker_logic.evaluate_hand(self.hands[player]['cards'])[1]
        win_rate = self.poker_logic.estimate_win_rate(hand_strength)
        # print(f"{self.ai_label}'s hand strength: {hand_strength}")
        # print(f"{self.ai_label}'s win rate: {win_rate}")

        if current_bet == 0:
            # AI can choose to check or raise if no current bet is placed
            if win_rate > 0.20:
                raise_amount = 50  # AI opts to raise
                self.ai_bet(player, raise_amount)
                print(f"{self.ai_label} raises {raise_amount}.")
            else:
                # AI opts to check
                print(f"{self.ai_label} checks.")
        else:
            if win_rate >= 0.05:
                # AI opts to call if the win rate is reasonable
                call_amount = current_bet - self.hands[player].get('current_bet', 0)
                if call_amount > 0:
                    self.ai_bet(player, call_amount)
                    print(f"{self.ai_label} calls the current bet of {current_bet}.")
                else:
                    # AI checks if it already meets the current bet
                    print(f"{self.ai_label} checks.")
            else:
                # AI folds if the win rate is low
                self.ai_fold(player)
                print(f"{self.ai_label} folds due to low win rate.")

    def ai_bet(self, player, bet_amount):
        self.ai_label = f"Player {player + 1}"
        if bet_amount > self.player_chips[player]:
            print(f"{self.ai_label} does not have enough chips to bet {bet_amount}. Current chips: {self.player_chips[player]}")
            bet_amount = self.player_chips[player]
        self.player_chips[player] -= bet_amount
        self.hands[player]['current_bet'] += bet_amount
        self.pot += bet_amount
        print(f"{self.ai_label} bets {bet_amount} chips.")

    def ai_check(self, player):
        if self.hands[player].get('current_bet', 0) == 0:
            print(f"{self.ai_label} checks. No bet to match.")
        else:
            print(f"{self.ai_label} cannot check because there is a bet to match.")
    
    def ai_fold(self, player):
        # AI folds
        print(f"{self.ai_label} folds.")

        # Set the fold status for the player
        self.hands[player]['folded'] = True

        # Find the remaining player who hasn't folded
        other_player = next(player for player in range(self.players) if not self.hands[player].get('folded', False))
        print(f"Player {other_player + 1} wins by default!")
        self.distribute_pot([other_player])
        
        # End the game
        self.continue_game = False
        self.reset_for_new_round()

if __name__ == "__main__":
    state_size = 52  # Number of possible unique cards
    action_size = 3  # Bet, Check, Fold
    agent = PokerAI(state_size, action_size)
    game = PokerGame(players=2)
    game.play()